---
title: "SWATH-guidance"
author: "Wenguang Shao, Patrick Pedrioli, Chloe H. Lee and Ruedi Aebersold"
affiliation: Institute of Molecular Systems Biology, Department of Biology, ETH Zurich, Switzerland
date: "`r Sys.Date()`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{proBatch package overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
abstract: |
  This vignette describes how to apply `SWATH-guidance` package to infer protein abundance from DIA/SWATH-MS peptide measurements. The SWATH-guidance employs an automated machine learning approach to integrate information from multiple dimensions of DIA dataset and select peptides that accurately reflect abundance of their corresponding proteins, and have shown improved quantitative accuracy, consistency and reproducibility. 
  
  The workflow of SWATH-guidance consists of three major steps – intensity normalization, peptide/fragment selection and statistical analysis – in interface with widely used upstream and downstream statistical tools in DIA community. This package was programmed and intended for researchers in proteomics without extensive programming skills but with basic R knowledge. 

toc: yes
toc_depth: 2
numbersections: true

---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE, fig.pos = 'h')
```

```{r setup, include = FALSE}
chooseCRANmirror(graphics=FALSE, ind=1)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

## SWATH-guidance in DIA/SWATH-MS analysis workflow 
A recent advancement in data-independent acquisition (DIA)/ SWATH-MS methods allowed complete and precise measurements of thousands of peptides in a reproducible manner. However, despite development of many computational tools to extract and evaluate targeted peptide features, an accurate estimation of protein abundance from their corresponding peptide intensities still remains challenging. The main difficulties arise from: 

+ Interference; a typical DIA/SWATH-MS workflow co-fragment multiple precursor ions by wider windows, which may potentially interfere traces of similar m/z values;
+ Error introduced during data analysis, resulting in incorrectly identified peptides;
+ Peptide and/or experiment specific properties e.g. presence of post-translational modifications or sequence motives in peptide sequence. 

To circumvent the limitations in the current approach, we present SWATH-guidance, an automated machine learning-based approach for an accurate and sensitive detection of protein abundance, and this strategy exhibited higher accuracy, consistency and reproducibility on quantitative gold standard (QGS) dataset in comparison to conventional methods, top3 and mapDIA [Shao et al.]. Furthermore, the SWATH-guidance is readily compatible with widely used statistical tools in the DIA community such as PECA and mapDIA.  

This SWATH-guidance package provides functions to import and convert SWATH data compatible for downstream analysis, normalize fragment/peptide-level intensities, calculate peptide features, selects peptides/fragment that preserves the major quantitative pattern and infer protein abundance. 

Thus, we believe this will be a valuable tool to accurately infer protein abundances, particularly useful to quantify proteins with smaller abundance changes, and is readily applicable for popular life science research such as large-scale sample profiling, biomarker discovery and personalized medicine. 

## Implementation of linear discriminant analysis (LDA) model for feature selection
The highlight of the package is implementation of automated machine learning approach to integrate multiple features to infer protein inference. We employed linear discriminant analysis (LDA) model to predict for peptides that accurately reflect the abundance of their corresponding proteins.

In essence, the LDA algorithm finds directions, or linear discriminates, that maximize the separation between classes i.e. good or bad peptides, then use these directions to predict the class of each peptide. The model outputs the probability of belonging to a given class based on one or multiple predictor variables i.e. computed feature statistics. 

We provide trained LDA model using QGS dataset but users can train an LDA model using their own dataset. Refer to Part 3 for step-by-step demonstration to train an LDA model of own dataset.  

# Package installation and data loading 

## Installing SWATH-guidance
To install the SWATH-guidance package, the following commands can be executed in R:
```{r install_proBatch, fig.show='hold', eval = FALSE}
# Once the SWATH-guidance package is in Bioconductor, can easily install by: 
install.packages("SWATH-guidance") 
library(SWATH-guidance)

# Alternatively, install the development version from GitHub:
install.packages("devtools")
devtools::install_github("shaowenguang/guidance ", build_vignettes = TRUE)
```

```{r dependencies}
library(data.table)
library(MASS)
library(ggplot2)
library(grid)
library(gplots)
library(plyr)
library(GGally)
library(ggfortify)
library(gridExtra)
```


## Example data: quantitative golden standard (QGS) dataset 
The example data is a reduced OpenSWATH output file generated from the Quantification Gold Standard (QGS) dataset [figure 1]. The dataset contains different ratio of *E.coli* and mouse samples to display differential expressions in *E.coli* and mouse proteins and equal expression pattern of Human proteins. The data is annotated into two biological samples, A and B. 

```{r QGS_dataset, include = TRUE, fig.align = "center", echo=FALSE, fig.cap="Design of Quantitative Golden Standard (QGS)", out.width = '50%'}
#knitr::include_graphics("Batch_effects_workflow_staircase.png")
```

## Loading the data 
The package provides a function to import SWATH data and sample annotation:
```{r load_data, fig.show='hold'}
library(Prom)
peptideIons <- import_openswath(search_results= "D:/SWATH-guidance/feature_alignment.csv", 
                                sample_annotation="D:/SWATH-guidance/sample_annotation", level="PeptideIon") 
```

The users can import SWATH data of different peptide/fragment levels by denoting `level` to `"PeptideIon"`,`"Transition"`, `"Peptide"`or `"PeptideWithMod"`. Note that downstream analysis is subjected to change depending on peptide/fragment level of imported data. (Details/ characteristic of each level?) 


# Analyze data 
We hereby show a step-by-step demonstration to normalize peptide/fragment-level intensities, calculate and select features and conduct statistical tests to accurately infer protein abundance from DIA/SWATH-MS data. 

## Normalize data
The openSWATH data is in long format to facilitate downstream analysis to normalize, compute features and select features, the data needs to be converted into matrix format. We provide a helpful utility function to convert from long to wide format data.  

The `normalize_data()` provides options to normalize intensities across different samples by `"mediancenter"`,`"quantile"`, `"TIC"` or`"iRT"`. If there is no need to normalize intensities, can denote `normalization = "none”`. 

For implementation, users can also specify how to treat missing values via `replaceNA =` either to `"remove"` or `"keep"` them, alternatively to replace them by `"zero"` or `“min_intensity"`. 

```{r normalize_data, fig.show='hold'}
all_peptideIons <- long2wide(peptideIons)
all_peptideIons_normalized <- normalize_data(all_peptideIons, replaceNA="keep", normalization="mediancenter")
```

## Calculate features
The `merge_replicate()` merges biological replicates under column name `“SampleName”` and computes average intensity, coefficient of variation (CV) and number of missing values for each sample. 

In addition to sample-oriented features, `calc_feature()` computes statistics among peptides corresponding to the same protein. These features include average intensity, coefficient of variation (CV), number of missing values, average score, standard deviation, median Pearson correlation coefficient (PCC), median spearman correlation coefficient (SCC) and median absolute deviation (MAD). We also display scaled statistics where the numeric values are centered by subtracting the mean and scaled by dividing their standard deviation. 

```{r calculate_feature, fig.show='hold'}
cons_peptideIons <- merge_replicates(all_peptideIons_normalized, anno)
cons_peptideIons_features <- calc_features(cons_peptideIons)

library(knitr)
library(dplyr)
kable(cons_peptideIons_features[1:5,] %>%
  select(c("PeptideIon", 
           "feature_mean_intensity_all","feature_cv_intensity_all", "feature_numNA_intensity_all",
           "feature_averaged_score_all", "feature_sd_width_all", "feature_median_PCC",         
           "feature_median_SCC", "feature_MAD_dist", "median_PCC_PerProt")))
```

Visualize the feature (barplots, correlation matrix, trend lines for subset of peptides as supplmentary diagram)


## Perform selection on features 
After calculating feature statistics, we implemented linear discriminant analysis (LDA) model to combine sub-scores describing various features into a poster probability of being a RARE (reproducible abundance representative entities). These RAREs are subset of peptides that accurately and reliably reflects the abundance of their corresponding proteins. 

In this analysis, we assume that the LDA models have already been trained or no training is necessary (see Part II on how to train models with own datasets). 

```{r perform_selection, fig.show='hold'}
test <- perform_selection(cons_peptideIons_features) 
hist(test$prob, main = "Histogram of posterior probability")

```

## Estimate protein abundance 
First, to obtain an optimal peptide to protein inference, users can pre-process the feature-selected dataset prior to protein inference step. 

+ Filter peptides by posterior probability threshold: users can filter peptides with a decent posterior probability e.g. probability > 0.2 
```{r protein_infer_filter, fig.show='hold'}
test_yesFiltered <- test[prob > 0.2, ]
```

+ Impute missing values: in the case of missing values, we provide `imputate_missing_values()` to impute a value following uniform distribution between minimum \times (0.1 \times CV, 1.1 \times CV)
```{r protein_infer_impute, fig.show='hold'}
test_yesFiltered_yesImputated <- imputate_missing_values(test_yesFiltered, c(3:17))
```

Once the data is ready to proceed with protein inference step, we provide `pept2prot()` to infer protein abundance from peptide/fragment-level intensities. We provide a number of parameters that users can denote for an optimal estimation of protein abundance. 

+ Number of peptides to be utilized for protein inference by denoting a numeric value at `topN`. 
```{r protein_infer_topN, fig.show='hold'}
test_yesFiltered_top1_sum_yesImputated <- merge_replicates(pept2prot(test_yesFiltered_yesImputated, 
                                           "prob", topN = 1, aggfun="sum",bool_weighted_by_prob=F), anno)

test_yesFiltered_top3_sum_yesImputated <- merge_replicates(pept2prot(test_yesFiltered_yesImputated, 
                                           "prob", 3, aggfun="sum", bool_weighted_by_prob=F), anno)

test_yesFiltered_top99999_sum_yesImputated <- merge_replicates(pept2prot(test_yesFiltered_yesImputated, 
                                           "prob", 99999, aggfun="sum", bool_weighted_by_prob=F), anno)
```

+ Method to aggregate peptide/fragment intensities by `aggfun = “mean”` or `“sum”` 
```{r protein_infer_aggfunc, fig.show='hold'}
test_yesFiltered_top3_mean_yesImputated <- merge_replicates(pept2prot(test_yesFiltered_yesImputated, 
                                            "prob", 3, aggfun="mean", bool_weighted_by_prob=F), anno)
```

+ Weight intensity of each peptide by their posterior probability by boolean model in estimating protein abundance by denoting `bool_weighted_by_prob = TRUE` 
```{r protein_infer_weight, fig.show='hold'}
test_yesFiltered_top3_sum_yesImputated_yesWeighted <- merge_replicates(pept2prot(
  test_yesFiltered_yesImputated, "prob", 3, aggfun="sum", bool_weighted_by_prob=T), anno)
```

*Illustrate different results depending on different parameters
*Give guidance or recommended parameter for each step 
*Description of when to use each parameter 

# Train linear discriminant analysis (LDA) model 
In this part, we demonstrate how to train a LDA model using own dataset to be used for the protein inference step. Here, we utilized the quantitative golden standard dataset which contained different ratios of *E.coli* proteins and the equal amount of human proteins between different samples. 
(Any requirement on the dataset to be utilized as training data?)

## Feature calculation 
To prepare for a training dataset, follow the data analysis steps in Part 2 up to feature calculation. Following `normalize_data()` and `calc_features()`, the dataset contains sample- and peptide-oriented features such as average sample intensity, sample CV, average peptide intensity, peptide CV, average peptide scores and etc. 

From the feature dataset, extract average intensity of each sample: 
```{r protein_infer_weight, fig.show='hold'}
index_mean_int <- which(grepl("^mean_intensity", names(cons_peptideIons_features)))
```

In particular, we have known ratio of *E.coli* proteins, and subset peptides that correspond to *E.coli* proteins: 
```{r protein_infer_weight, fig.show='hold'}
ecoli_std <- c(2,3,4,6,8)
ecoli <- cons_peptideIons_features[grepl("ECOL", cons_peptideIons_features$ProteinName), ]
```

“The LDA models describe relationship between peptides generated from the same protein i.e. intensity correlation. The feature describing the intensity correlation demonstrated completely different behaviors in *E.coli* proteins with different expression and in Human proteins with equal expression. Therefore, we took into consideration its inability to identify RAREs in datasets with unpredicted protein abundances and built two distinct LDA models: DE model and EE model without the feature.” We have shown that the intensity correlation plays an important role in discriminating RAREs. 

Compute correlation between the true standard quantity and average intensity on the measurement. Then, if the number of overlapping intensity is less than 4, the correlation is denoted as NA: 
```{r protein_infer_weight, fig.show='hold'}
ecoli[, cor_std := 0]
ecoli$cor_std <- apply(ecoli[, index_mean_int, with=F], 1, function(x) cor(x, ecoli_std, use="p"))
ecoli$cor_std[apply(ecoli[, index_mean_int, with=F], 1, function(x) count_pairwise_number(x, ecoli_std)) < 4] <- NA

```

Compute error in intensity measurements for each sample by comparing with true ratios for each sample: 
```{r protein_infer_weight, fig.show='hold'}
ecoli[, error := 0]
ecoli$error <- apply( cbind(abs(log2(ecoli$mean_intensity_A) - log2(ecoli$mean_intensity_B) - log2(2/3)), 
                            abs(log2(ecoli$mean_intensity_B) - log2(ecoli$mean_intensity_C) - log2(3/4)),
                            abs(log2(ecoli$mean_intensity_C) - log2(ecoli$mean_intensity_D) - log2(4/6)),
                            abs(log2(ecoli$mean_intensity_D) - log2(ecoli$mean_intensity_E) - log2(6/8)),
                            abs(log2(ecoli$mean_intensity_E) - log2(ecoli$mean_intensity_A) - log2(8/2)) ), 
                      1,mean_na)

```


Then, based on the values of intensity correlation or deviation from true measurement, the peptide is classified as good or bad peptide that reliably represent intensity of corresponding protein. 
```{r protein_infer_weight, fig.show='hold'}
ecoli[, label := "bad"]

# Threshold by intensity correlation 
#ecoli[ cor_std > 0.95, ]$label <- "good"

# Threshold by error 
ecoli[ error < 0.28, ]$label <- "good"
ecoli$label <- as.factor(ecoli$label)
```

## Establish LDA model 
After feature calculation and classification to good or bad peptides, the LDA model can be established based on selected features: 
```{r protein_infer_weight, fig.show='hold'}
index_feature_selected <- c("scaled_mean_intensity_all", "scaled_cv_intensity_all", 
                            "scaled_numNA_intensity_all", "scaled_averaged_score_all", 
                            "scaled_median_PCC", "scaled_sd_width_all", "label")

model_lda_ecoli <- get_lda_model(ecoli[numPerProt > 4 , ], index_feature_selected)
```


# SessionInfo

```{r sessionInfo, eval=TRUE}
sessionInfo()
```

# Citation

To cite this package, please use:
```{r citation}
citation('SWATH-guidance')
```

# References


